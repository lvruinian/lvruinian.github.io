## 知识点杂货铺
### JS 剩余参数和arguments对象的区别
剩余参数和 arguments对象之间的区别主要有三个：

+ 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。
+ arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。
+ arguments对象还有一些附加的属性 （如callee属性）

### CSS 浏览器前缀
-moz-：Firefox  
-webkit-：Safari 和 Chrome       
-o-：Opera

### 地址栏输入一个URL到页面呈现，中间会发生什么
输入URL，需要找到这个URL域名的服务器IP，浏览器首先会查找**缓存**，查看缓存中是否有记录  
缓存的查找记录为：浏览器缓存 -> 系统缓存 -> 路由器缓存  
缓存中若没有则去查找**系统hosts文件**中是否有记录，若没有则查询**DNS服务器**  
得到服务器IP地址后，浏览器根据IP及端口号，构造一个http请求，这个请求报文会包含请求信息，将这个http请求封装在一个**tcp包**中，tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的html给服务器  
因为html是一个树形结构，浏览器根据html构建**dom树**，在dom树的构建过程中如果与遇到JS脚本和外部JS链接，则会停止构建DOM树去执行和下载其它的代码，造成堵塞，这也是为什么推荐JS代码放在html代码的后面，之后根据外部/内部/内联样式，构建一个**CSS对象模型树（CSSOM树）**，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会**并行下载**，浏览器对每个域的并行下载有限制，一般是4-6个，其中我们需要关注缓存，一般通过Cache-Control,Last-Modify,Expires等首部字段控制。

Cache-Control和Expires的区别在于前者使用相对时间，后者使用基于服务器的绝对时间，因为存在时差问题，一般采用前者，请求设置了缓存的数据时，会先查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上次响应设置了ETag值会在这次请求时作为If-None-Match的值交给服务器校验，如果一致，继续校验Last-Modified，没有设置Etag则直接验证Last-Modified，再决定是否返回**304**

### 简单说一下cookie，localStorage，sessionStorage的区别
**cookie**
**生命周期：** 可设置失效时间，默认为关闭浏览器后失效
**存放数据：** 4K左右
**http请求：** 携带在http头中，如果使用cookie保存过多数据会带来性能问题
**易用性：** 需要自己封装，原生接口不友好

**localStorage**
**生命周期：** 除非被手动清除，否则永久保存
**存放数据：** 5M左右
**http请求：** 保存在客户端即浏览器，不与服务器通信
**易用性：** 采用原生接口，可自己封装

**sessionStorage**
**生命周期：** 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除
**存放数据：** 5M左右
**http请求：** 保存在客户端即浏览器，不与服务器通信
**易用性：** 采用原生接口，可自己封装

**应用场景**
http请求携带cookie信息，浪费带宽，尽可能少用，此外cookie需要指定作用域，不可以跨域使用，限制很多，但对于识别用户登录来说，cookie还是比storage好用，其他情况下可以用storage，localStorage在页面传递参数，sessionStorage可以保存一些临时数据，防止刷新页面后丢失了一些参数

## web性能优化
+ 降低请求量：合并资源，减少http请求数量，minify/gzip压缩，webp，lazyLoad  
+ 加快请求速度：预解析DNS，减少域名树，并行加载，CDN分发 
+ 缓存：http协议缓存请求，离线缓存manifest，离线数据缓存localStorage  
+ 渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline